/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./models.glb 
*/

import React, { useEffect, useRef, useMemo, useState } from 'react'
import { useGLTF, Points } from '@react-three/drei'
import { extend, useFrame } from '@react-three/fiber';

import * as THREE from 'three'

export default function Models({ name, getProgress, setProgress, color1, color2, ...props }) {
  const { nodes } = useGLTF('/static/models.glb')
  const direction = useRef(1)
  const index = useRef(0)

  const [particlePoints, setParticlePoints] = useState([]);
  const [sizePoints, setSizePoints] = useState([]);

  const [myGeo, setMyGeo] = useState();


  const [posIndex, setPosIndex] = useState(0)
  const [targetIndex, setTargetIndex] = useState(1)

  const myShaderMaterialRef = useRef()


  let torusRef = useRef()
  let suzanneRef = useRef()
  let sphereRef = useRef()
  let textRef = useRef()


  // initial use effect that runs before and after render that extracts postions and are normailsed to the same numer of points
  useEffect(() => {

    // Wait for all refs to exist
    if (!torusRef.current || !suzanneRef.current || !sphereRef.current || !textRef.current) return;

    let positions = []
    positions.push(torusRef.current.geometry.attributes.position)
    positions.push(suzanneRef.current.geometry.attributes.position)
    positions.push(sphereRef.current.geometry.attributes.position)
    positions.push(textRef.current.geometry.attributes.position)

    // objective create new position buffer attribute of all the same size

    let max = positions.reduce((acc, cur) => {
      return Math.max(acc, cur.count)
    }, 0)

    let updatedPositions = []

    // loop over positions and create new buffer attribute with the new max length just fill 0s if shorter
    for (let i = 0; i < positions.length; i++) {
      let newArr = new Float32Array(max * 3).fill(0) // we x3 for xyz coords

      for (let j = 0; j < positions[i].array.length; j++) {
        newArr[j] = positions[i].array[j]
      }

      // the indexs after the max length lets fill them up with fluff of other none positions

      for (let j = positions[i].count * 3; j < max * 3; j += 3) {
        let randomIndex = Math.floor(positions[i].count * Math.random()) * 3   //   Integer((number of position) * random(0->1)) * 3 ---> this accounts for xyz
        newArr[j] = newArr[randomIndex]
        newArr[j + 1] = newArr[randomIndex + 1]
        newArr[j + 2] = newArr[randomIndex + 2]
      }

      // updatedPositions.push(new THREE.Float32BufferAttribute(newArr, 3))
      updatedPositions.push(newArr) // Note when useing the R3F <Points> component we need to parse a Float32 not a buffer attribute

    }
    // at this point updatedPositions all have the same lenther position arrays ~30726


    setParticlePoints(updatedPositions)


    // crete a random attribute for particle size... note this can be used for all models
    let sizeArray = new Float32Array(max)
    for (let i = 0; i < sizeArray.length; i++) {
      sizeArray[i] = Math.random()
    }
    setSizePoints(sizeArray)

    // update our pos and target index state vals with initial 2 geos

    // we are jsut extracting the poistions array from the mesh and updating the state that hold the points coords
    let geo = new THREE.BufferGeometry()
    geo.setAttribute('position', new THREE.Float32BufferAttribute(updatedPositions[0], 3))
    geo.setAttribute('aPositionTarget', new THREE.Float32BufferAttribute(updatedPositions[1], 3))
    geo.setAttribute('aSize', new THREE.Float32BufferAttribute(sizePoints, 1))


    setMyGeo(geo)
  }, [])

  // this is triggered when we make an index change in our uodate geo
  useEffect(() => {
    if (!particlePoints.length) return;

    // Dispose old geometry
    if (myGeo) {
      myGeo.dispose();
    }

    // Create new geometryf
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(particlePoints[posIndex], 3));
    geo.setAttribute('aPositionTarget', new THREE.Float32BufferAttribute(particlePoints[targetIndex], 3));
    geo.setAttribute('aSize', new THREE.Float32BufferAttribute(sizePoints, 1))



    setMyGeo(geo);

  }, [posIndex, targetIndex, particlePoints]);

  // updates the points when the geo is changed

  const updateGeo = (idx) => {
    if (!particlePoints.length) return;
    if (idx % 2 == 1) {
      setPosIndex(prev => (prev + 2) % particlePoints.length);
    } else {
      setTargetIndex(prev => (prev + 2) % particlePoints.length);
    }

    // 0 p=0 t=1 (d+) --> half cycle ---> switch to negative
    // 1 p=2 t=1 (d-) --> full cycle ---> switched to positive
    // 2 p=2 t=3 (d+) --> 1.5 cycle ---> 
    // 3 p=0 t=3 (d-) --> complete 2 cycle

    // 0 torus
    // 1 suzanne
    // 2 sphere
    // 3 text

  };


  useFrame((state, delta) => {

    const elapsedTime = state.clock.elapsedTime

    // uniform update when leva controls change (this progress is getting parsed from experience)
    if (myShaderMaterialRef.current) {
      myShaderMaterialRef.current.uniforms.uProgress.value = getProgress()
      myShaderMaterialRef.current.uniforms.uColor1.value.set(color1)
      myShaderMaterialRef.current.uniforms.uColor2.value.set(color2)
    }

    // update based on progress also toggle direction and update model when progress == 1
    let curProgress = getProgress()
    if ((curProgress > 1 && direction.current > 0) || (curProgress < 0 && direction.current < 0)) {
      // setDirection(direction * -1)
      direction.current *= -1
      index.current = (index.current + 1) % particlePoints.length
      updateGeo(index.current)
    }
    setProgress(curProgress + direction.current * delta / 5)


    // state.camera.lookAt(0, 0, 0);
  })

  return (
    <group {...props} dispose={null}>

      {/* Note we are frustum culling instead of computing bounding sphere (it's hard with the multi attribute tobject and already optimised so no frustrum culling is not a big deal) */}
      <points geometry={myGeo} frustumCulled={false}>
        <myShaderMaterial ref={myShaderMaterialRef} blending={THREE.AdditiveBlending} depthWrite={false} />
      </points>


      {/* Use <Points> when we are manuallly providing positions
      use primitive <points> when we are passing a geometry */}

      {/* <Points positions={particlePoints[0]}>
        <myShaderMaterial blending={THREE.AdditiveBlending} depthWrite={false} />
      </Points> */}

      <mesh
        ref={torusRef}
        geometry={nodes.Torus001.geometry}
        visible={false}
      >
      </mesh>


      <mesh
        ref={suzanneRef}
        geometry={nodes.Suzanne.geometry}
        material={nodes.Suzanne.material}
        visible={false}

      />

      <mesh
        ref={sphereRef}
        geometry={nodes.Icosphere.geometry}
        material={nodes.Icosphere.material}
        visible={false}

      />

      <mesh
        ref={textRef}
        geometry={nodes.Text002.geometry}
        material={nodes.Text002.material}
        visible={false}

      />


    </group>
  )
}

useGLTF.preload('/models.glb')
