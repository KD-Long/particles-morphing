/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./models.glb 
*/

import React, { useEffect, useRef, useMemo, useState } from 'react'
import { useGLTF, Points } from '@react-three/drei'
import { extend, useFrame } from '@react-three/fiber';

import * as THREE from 'three'

export default function Models({ name, getProgress, children, ...props }) {
  const { nodes } = useGLTF('/static/models.glb')

  const [particlePoints, setParticlePoints] = useState([]);
  const [suzanne, setSuzanne] = useState();

  const myShaderMaterialRef = useRef()


  let torusRef = useRef()
  let suzanneRef = useRef()
  let sphereRef = useRef()
  let textRef = useRef()


  useEffect(() => {

    // Wait for all refs to exist
    if (!torusRef.current || !suzanneRef.current || !sphereRef.current || !textRef.current) return;

    let positions = []
    positions.push(torusRef.current.geometry.attributes.position)
    positions.push(suzanneRef.current.geometry.attributes.position)
    positions.push(sphereRef.current.geometry.attributes.position)
    positions.push(textRef.current.geometry.attributes.position)

    // objective create new position buffer attribute of all the same size

    let max = positions.reduce((acc, cur) => {
      return Math.max(acc, cur.count)
    }, 0)

    let updatedPositions = []

    // loop over positions and create new buffer attribute with the new max length just fill 0s if shorter
    for (let i = 0; i < positions.length; i++) {
      let newArr = new Float32Array(max * 3).fill(0) // we x3 for xyz coords

      for (let j = 0; j < positions[i].array.length; j++) {
        newArr[j] = positions[i].array[j]
      }

      // the indexs after the max length lets fill them up with fluff of other none positions

      for (let j = positions[i].count * 3; j < max * 3; j += 3) {
        let randomIndex = Math.floor(positions[i].count * Math.random()) * 3   //   Integer((number of position) * random(0->1)) * 3 ---> this accounts for xyz
        newArr[j] = newArr[randomIndex]
        newArr[j + 1] = newArr[randomIndex + 1]
        newArr[j + 2] = newArr[randomIndex + 2]
      }



      // updatedPositions.push(new THREE.Float32BufferAttribute(newArr, 3))
      updatedPositions.push(newArr) // Note when useing the R3F <Points> component we need to parse a Float32 not a buffer attribute

    }
    // at this point updatedPositions all have the same lenther position arrays ~30726

    // we are jsut extracting the poistions array from the mesh and updating the state that hold the points coords

    let geo = new THREE.BufferGeometry()
    geo.setAttribute('position', new THREE.Float32BufferAttribute(updatedPositions[1], 3))
    geo.setAttribute('aPositionTarget', new THREE.Float32BufferAttribute(updatedPositions[2], 3))


    setSuzanne(geo)

    setParticlePoints(updatedPositions)



    console.log(updatedPositions)


  }, [])
  useFrame((state, delta) => {

    const elapsedTime = state.clock.elapsedTime

    // uniform update when leva controls change (this progress is getting parsed from experience)
    if (myShaderMaterialRef.current) {
      myShaderMaterialRef.current.uniforms.uProgress.value = getProgress()
    }

    // sphereRef.current.rotation.x = - elapsedTime * 0.1
    // particlesRef.current.rotation.y = elapsedTime * 0.5


    // state.camera.lookAt(0, 0, 0);
  })

  return (
    <group {...props} dispose={null}>





      <points geometry={suzanne}>
        <myShaderMaterial ref={myShaderMaterialRef} blending={THREE.AdditiveBlending} depthWrite={false} />
      </points>

      {/* <Points positions={particlePoints[0]}>
        <myShaderMaterial blending={THREE.AdditiveBlending} depthWrite={false} />
      </Points> */}

      {/* <Points positions={particlePoints[0]}>
        <myShaderMaterial blending={THREE.AdditiveBlending} depthWrite={false} />
      </Points> */}

      {/* <Points positions={particlePoints[1]}>
        <myShaderMaterial blending={THREE.AdditiveBlending} depthWrite={false} />
      </Points>


      <Points positions={particlePoints[2]}>
        <myShaderMaterial blending={THREE.AdditiveBlending} depthWrite={false} />
      </Points>


      <Points positions={particlePoints[3]}>
        <myShaderMaterial blending={THREE.AdditiveBlending} depthWrite={false} />
      </Points> */}




      <mesh
        ref={torusRef}
        geometry={nodes.Torus001.geometry}
        visible={false}
      >
      </mesh>


      <mesh
        ref={suzanneRef}
        geometry={nodes.Suzanne.geometry}
        material={nodes.Suzanne.material}
        visible={false}

      />

      <mesh
        ref={sphereRef}
        geometry={nodes.Icosphere.geometry}
        material={nodes.Icosphere.material}
        visible={false}

      />


      <mesh
        ref={textRef}
        geometry={nodes.Text002.geometry}
        material={nodes.Text002.material}
        visible={false}

      />


    </group>
  )
}

useGLTF.preload('/models.glb')
